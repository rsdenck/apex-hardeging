#!/usr/bin/env bash
# Apex Monitoring Solutions
# Autor: ranlens.denck
# hard_db.sh
# Tuning e hardening do SO voltado para servidores exclusivamente de Banco de Dados.
# Uso: hard_db.sh [--show|--dry-run|--apply|--revert|--help]
#
# Principais ações:
# - coleta inventário (memória, cpu, tcp, swap, cache, processos)
# - gera e aplica sysctl em /etc/sysctl.d/99-hard-db.conf
# - ajusta limits em /etc/security/limits.d/99-hard-db.conf
# - recomendações seguras e reversíveis (backup automático)
# - modo dry-run para só visualizar mudanças
# - criado com funções, trap e checks (estilo procedural/funcional)
# ------------------------------------------------------------------------------------
set -euo pipefail
IFS=$'\n\t'

SCRIPT_NAME="$(basename "$0")"
BACKUP_DIR="/var/backups/${SCRIPT_NAME}_$(date +%Y%m%d_%H%M%S)"
SYSCTL_FILE="/etc/sysctl.d/99-hard-db.conf"
LIMITS_FILE="/etc/security/limits.d/99-hard-db.conf"
SYSCTL_BKP="${BACKUP_DIR}/sysctl.conf.orig"
LIMITS_BKP="${BACKUP_DIR}/limits.orig"
DRY_RUN=false
APPLY=false
REVERT=false
SHOW_ONLY=false

# trap: garantir que saídas de erro façam log
trap 'rc=$?; if [ $rc -ne 0 ]; then echo "[ERROR] Erro no script: código $rc"; fi' EXIT

require_root() {
  if [ "$(id -u)" -ne 0 ]; then
    echo "Este script precisa ser executado como root. Use sudo." >&2
    exit 1
  fi
}

mk_backup_dir() {
  mkdir -p "$BACKUP_DIR"
  echo "Criado backup em: $BACKUP_DIR"
}

# --- coleta de inventário ---
collect_inventory() {
  echo "=== INVENTÁRIO DO SISTEMA ==="
  echo "Hostname: $(hostname -f 2>/dev/null || hostname)"
  echo "Data: $(date -u +"%Y-%m-%d %H:%M:%SZ")"
  echo
  echo "-- MEMÓRIA --"
  free -h
  echo
  echo "-- CPU --"
  lscpu | sed -n '1,12p'
  echo "Núcleos lógicos: $(nproc --all)"
  echo
  echo "-- TCP / conexões (sumário) --"
  ss -s
  echo
  echo "-- SWAP --"
  swapon --show || echo "Sem swap habilitado"
  echo
  echo "-- CACHE (memória usada por cache/buffers) --"
  awk '/^Mem:/{print "Mem total (kB): "$2}' /proc/meminfo || true
  grep -E 'Cached|Buffers' /proc/meminfo || true
  echo
  echo "-- PROCESSOS (top 10 por CPU) --"
  ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu | head -n 11
  echo "=============================="
}

# calcula valores recomendados baseados em memória total
# retorna valores em KB ou porcentagens conforme necessário
calc_recommendations() {
  MEM_TOTAL_KB=$(awk '/MemTotal/ {print $2}' /proc/meminfo)
  MEM_TOTAL_MB=$(( MEM_TOTAL_KB / 1024 ))
  CPUS=$(nproc --all)
  # Algumas heurísticas:
  # - vm.swappiness: 1 (DB servers preferem manter data in RAM)
  # - vm.dirty_ratio/dirty_background_ratio: reduz para evitar spikes de IO
  # - vm.vfs_cache_pressure: reduzir para favorecer cache de filesystem para DB
  # - fs.file-max: proporcional à memória/2 * threads
  FS_FILE_MAX=$(( MEM_TOTAL_MB * 100 ))    # heurística conservadora
  if [ "$FS_FILE_MAX" -lt 200000 ]; then FS_FILE_MAX=200000; fi
  # max_map_count - recomendado para Oracle/Java large heaps
  MAX_MAP_COUNT=262144
  # shared memory segment sizes are DB-specific; só sugerimos: kernel.shmmax ~ 25% mem
  SHMMAX=$(( MEM_TOTAL_KB / 4 * 1024 )) # em bytes (mem_kb/4 * 1024)
  # overcommit memory para DB -> 2 (estrito) em muitos cases, mas usar 1 para evitar OOM em algumas configs.
  OVERCOMMIT=1

  # TCP params (DB servers lidam com conexões internas intensas)
  SOMAXCONN=65535
  NET_CORE_RMEM_DEFAULT=262144
  NET_CORE_WMEM_DEFAULT=262144

  # dirty* em centiseconds
  DIRTY_EXPIRE=3000          # 30s
  DIRTY_WRITEBACK=500        # 5s

  # expor via globals para uso posterior
  export MEM_TOTAL_MB CPUS FS_FILE_MAX MAX_MAP_COUNT SHMMAX OVERCOMMIT \
         SOMAXCONN NET_CORE_RMEM_DEFAULT NET_CORE_WMEM_DEFAULT DIRTY_EXPIRE DIRTY_WRITEBACK
}

generate_sysctl_content() {
  cat <<EOF
# Generated by ${SCRIPT_NAME} for DATABASE servers
# Date: $(date -u +"%Y-%m-%d %H:%M:%SZ")
# NOTE: backups em ${BACKUP_DIR}
# VM / memory
vm.swappiness = 1
vm.vfs_cache_pressure = 50
vm.overcommit_memory = ${OVERCOMMIT}
vm.overcommit_ratio = 50
vm.max_map_count = ${MAX_MAP_COUNT}

# Dirty page writeback tuning (reduce IO spikes)
vm.dirty_expire_centisecs = ${DIRTY_EXPIRE}
vm.dirty_writeback_centisecs = ${DIRTY_WRITEBACK}
vm.dirty_ratio = 10
vm.dirty_background_ratio = 5

# Shared memory (sugestão)
kernel.shmmax = ${SHMMAX}
kernel.shmall = $(( SHMMAX / 4096 ))

# File handles
fs.file-max = ${FS_FILE_MAX}

# Network (reduce connection backlog issues, tuned for DB traffic)
net.core.somaxconn = ${SOMAXCONN}
net.core.netdev_max_backlog = 250000
net.core.rmem_default = ${NET_CORE_RMEM_DEFAULT}
net.core.wmem_default = ${NET_CORE_WMEM_DEFAULT}
net.core.rmem_max = $(( NET_CORE_RMEM_DEFAULT * 8 ))
net.core.wmem_max = $(( NET_CORE_WMEM_DEFAULT * 8 ))
net.ipv4.tcp_max_syn_backlog = 40960
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 15
net.ipv4.ip_local_port_range = 10240 65535

# TCP tuning for latency-sensitive DB traffic
net.ipv4.tcp_timestamps = 1
net.ipv4.tcp_sack = 1
net.ipv4.tcp_window_scaling = 1
EOF
}

generate_limits_content() {
  cat <<EOF
# Generated by ${SCRIPT_NAME}
# Limits for DB processes (open files and nproc)
# Recomenda-se aplicar no usuário do DB (ex: postgres, mysql, oracle)
* soft nofile  65536
* hard nofile  200000
* soft nproc   65536
* hard nproc   65536
# core dumps disabled (policy; pode ser alterado se precisar de core)
* soft core 0
EOF
}

apply_sysctl() {
  echo "[*] Aplicando sysctl temporariamente..."
  # escreve arquivo temporário e aplica com sysctl -p
  sysctl -w vm.swappiness=1 >/dev/null 2>&1 || true
  sysctl --system >/dev/null 2>&1 || true
  echo "[*] sysctl aplicado temporariamente. Persistindo em ${SYSCTL_FILE}"
}

persist_sysctl_file() {
  echo "Gerando arquivo ${SYSCTL_FILE}..."
  # backup existente (se houver)
  if [ -f "${SYSCTL_FILE}" ]; then
    cp -av "${SYSCTL_FILE}" "${BACKUP_DIR}/99-hard-db.conf.bak"
    echo "Backup de ${SYSCTL_FILE} salvo em ${BACKUP_DIR}"
  fi
  generate_sysctl_content > "${SYSCTL_FILE}.tmp"
  mv "${SYSCTL_FILE}.tmp" "${SYSCTL_FILE}"
  # carregar as novas configurações
  sysctl --system
  echo "Persistido sysctl em ${SYSCTL_FILE}"
}

persist_limits_file() {
  echo "Gerando arquivo ${LIMITS_FILE}..."
  if [ -f "${LIMITS_FILE}" ]; then
    cp -av "${LIMITS_FILE}" "${BACKUP_DIR}/99-hard-db.limits.bak"
    echo "Backup de ${LIMITS_FILE} salvo em ${BACKUP_DIR}"
  fi
  generate_limits_content > "${LIMITS_FILE}.tmp"
  mv "${LIMITS_FILE}.tmp" "${LIMITS_FILE}"
  echo "Persistido limits em ${LIMITS_FILE}"
}

disable_transparent_hugepages() {
  # THP pode prejudicar alguns DBs (desempenho imprevisível). Só tentar se path existir.
  if [ -d /sys/kernel/mm/transparent_hugepage ]; then
    echo "Tentando desabilitar Transparent HugePages (THP) temporariamente..."
    if [ -w /sys/kernel/mm/transparent_hugepage/enabled ]; then
      echo never > /sys/kernel/mm/transparent_hugepage/enabled || true
      echo "THP: $(cat /sys/kernel/mm/transparent_hugepage/enabled 2>/dev/null || true)"
    fi
    if [ -w /sys/kernel/mm/transparent_hugepage/defrag ]; then
      echo never > /sys/kernel/mm/transparent_hugepage/defrag || true
      echo "THP defrag: $(cat /sys/kernel/mm/transparent_hugepage/defrag 2>/dev/null || true)"
    fi
    # persistência por rc.local (fallback)
    if [ -f /etc/rc.local ] || [ -d /etc/systemd/system ]; then
      echo "# disabled THP for DB servers" > /etc/sysctl.d/99-disable-thp.conf 2>/dev/null || true
    fi
  fi
}

do_apply() {
  require_root
  mk_backup_dir
  calc_recommendations
  echo "[*] Aplicando tuning para DATABASE - modo APPLY"
  persist_sysctl_file
  persist_limits_file
  disable_transparent_hugepages
  echo "[*] Aplicado. Verifique logs em ${BACKUP_DIR}"
  echo "Recomendações adicionais:"
  echo "- Ajuste de parâmetros específicos do DB (shared_buffers, innodb_buffer_pool_size, etc) deve ser feito no próprio DB"
  echo "- Verifique I/O scheduler (noop ou mq-deadline) para discos NVMe/HBA"
  echo "- Considere desabilitar swap em sistemas com RAM suficiente (com cautela)"
}

do_dry_run() {
  calc_recommendations
  echo "=== DRY RUN - conteúdo sugerido para ${SYSCTL_FILE} ==="
  generate_sysctl_content
  echo
  echo "=== DRY RUN - conteúdo sugerido para ${LIMITS_FILE} ==="
  generate_limits_content
  echo
  echo "Observações:"
  echo "- Execute 'sudo $0 --apply' para aplicar as mudanças (irá criar backups em ${BACKUP_DIR})."
}

do_show() {
  collect_inventory
  echo
  calc_recommendations
  echo
  echo "Sugestões resumidas (valores calculados):"
  echo "MEM_TOTAL_MB=${MEM_TOTAL_MB}, CPUS=${CPUS}"
  echo "fs.file-max=${FS_FILE_MAX}"
  echo "kernel.shmmax=${SHMMAX}"
  echo "max_map_count=${MAX_MAP_COUNT}"
}

do_revert() {
  require_root
  if [ -d "${BACKUP_DIR}" ]; then
    echo "Restaurando backups em ${BACKUP_DIR} (se existirem)..."
    # tentar restaurar arquivos de backup salvos no mesmo run
    if [ -f "${BACKUP_DIR}/99-hard-db.conf.bak" ]; then
      cp -av "${BACKUP_DIR}/99-hard-db.conf.bak" "${SYSCTL_FILE}"
      sysctl --system
      echo "sysctl restaurado."
    else
      echo "Nenhum backup anterior de sysctl encontrado em ${BACKUP_DIR}."
    fi
    if [ -f "${BACKUP_DIR}/99-hard-db.limits.bak" ]; then
      cp -av "${BACKUP_DIR}/99-hard-db.limits.bak" "${LIMITS_FILE}"
      echo "limits restaurado."
    else
      echo "Nenhum backup anterior de limits encontrado em ${BACKUP_DIR}."
    fi
  else
    echo "Nenhum backup criado por este script encontrado. Verifique /var/backups"
    exit 1
  fi
}

print_help() {
  cat <<EOF
Uso: $SCRIPT_NAME [--show|--dry-run|--apply|--revert|--help]

--show     : apenas coleta e exibe inventário e recomendações
--dry-run  : mostra os arquivos sysctl/limits sugeridos (não aplica)
--apply    : aplica as alterações (requer root), grava backups em ${BACKUP_DIR}
--revert   : reverte a partir do backup gerado pelo script (executar no mesmo host)
--help     : esta ajuda
EOF
}

# --- main CLI parsing ---
if [ $# -eq 0 ]; then
  print_help
  exit 0
fi

while [ $# -gt 0 ]; do
  case "$1" in
    --show) SHOW_ONLY=true; shift ;;
    --dry-run) DRY_RUN=true; shift ;;
    --apply) APPLY=true; shift ;;
    --revert) REVERT=true; shift ;;
    --help) print_help; exit 0 ;;
    *) echo "Opção desconhecida: $1"; print_help; exit 1 ;;
  esac
done

if [ "$SHOW_ONLY" = true ]; then
  do_show
  exit 0
fi

if [ "$DRY_RUN" = true ]; then
  do_dry_run
  exit 0
fi

if [ "$REVERT" = true ]; then
  do_revert
  exit 0
fi

if [ "$APPLY" = true ]; then
  do_apply
  exit 0
fi

echo "Nenhuma ação selecionada. Use --help para ver opções."
exit 1
